"use strict";(globalThis.webpackChunkpswidersk_page=globalThis.webpackChunkpswidersk_page||[]).push([[1680],{1680:n=>{n.exports="import {\n  protoOf180f3jzyo7rfj as protoOf,\n  initMetadataForObject1cxne3s9w65el as initMetadataForObject,\n  VOID3gxj6tk5isa35 as VOID,\n  initMetadataForClassbxx6q50dy2s7 as initMetadataForClass,\n  toString30pk9tzaqopn as toString,\n} from './kotlin-kotlin-stdlib.mjs';\n//region block: imports\n//endregion\n//region block: pre-declaration\ninitMetadataForClass(atomicfu$TraceBase, 'TraceBase');\ninitMetadataForObject(None, 'None', VOID, atomicfu$TraceBase);\ninitMetadataForClass(AtomicRef, 'AtomicRef');\ninitMetadataForClass(AtomicBoolean, 'AtomicBoolean');\n//endregion\nfunction None() {\n  None_instance = this;\n  atomicfu$TraceBase.call(this);\n}\nvar None_instance;\nfunction None_getInstance() {\n  if (None_instance == null)\n    new None();\n  return None_instance;\n}\nfunction atomicfu$TraceBase() {\n}\nprotoOf(atomicfu$TraceBase).atomicfu$Trace$append$1 = function (event) {\n};\nprotoOf(atomicfu$TraceBase).atomicfu$Trace$append$2 = function (event1, event2) {\n};\nprotoOf(atomicfu$TraceBase).atomicfu$Trace$append$3 = function (event1, event2, event3) {\n};\nprotoOf(atomicfu$TraceBase).atomicfu$Trace$append$4 = function (event1, event2, event3, event4) {\n};\nfunction AtomicRef(value) {\n  this.kotlinx$atomicfu$value = value;\n}\nprotoOf(AtomicRef).y1k = function (_set____db54di) {\n  this.kotlinx$atomicfu$value = _set____db54di;\n};\nprotoOf(AtomicRef).z1k = function () {\n  return this.kotlinx$atomicfu$value;\n};\nprotoOf(AtomicRef).atomicfu$compareAndSet = function (expect, update) {\n  if (!(this.kotlinx$atomicfu$value === expect))\n    return false;\n  this.kotlinx$atomicfu$value = update;\n  return true;\n};\nprotoOf(AtomicRef).atomicfu$getAndSet = function (value) {\n  var oldValue = this.kotlinx$atomicfu$value;\n  this.kotlinx$atomicfu$value = value;\n  return oldValue;\n};\nprotoOf(AtomicRef).toString = function () {\n  return toString(this.kotlinx$atomicfu$value);\n};\nfunction atomic$ref$1(initial) {\n  return atomic$ref$(initial, None_getInstance());\n}\nfunction AtomicBoolean(value) {\n  this.kotlinx$atomicfu$value = value;\n}\nprotoOf(AtomicBoolean).a1l = function (_set____db54di) {\n  this.kotlinx$atomicfu$value = _set____db54di;\n};\nprotoOf(AtomicBoolean).z1k = function () {\n  return this.kotlinx$atomicfu$value;\n};\nprotoOf(AtomicBoolean).atomicfu$compareAndSet = function (expect, update) {\n  if (!(this.kotlinx$atomicfu$value === expect))\n    return false;\n  this.kotlinx$atomicfu$value = update;\n  return true;\n};\nprotoOf(AtomicBoolean).atomicfu$getAndSet = function (value) {\n  var oldValue = this.kotlinx$atomicfu$value;\n  this.kotlinx$atomicfu$value = value;\n  return oldValue;\n};\nprotoOf(AtomicBoolean).toString = function () {\n  return this.kotlinx$atomicfu$value.toString();\n};\nfunction atomic$boolean$1(initial) {\n  return atomic$boolean$(initial, None_getInstance());\n}\nfunction atomic$ref$(initial, trace) {\n  trace = trace === VOID ? None_getInstance() : trace;\n  return new AtomicRef(initial);\n}\nfunction atomic$boolean$(initial, trace) {\n  trace = trace === VOID ? None_getInstance() : trace;\n  return new AtomicBoolean(initial);\n}\n//region block: exports\nexport {\n  atomic$boolean$1 as atomic$boolean$1iggki4z65a2h,\n  atomic$ref$1 as atomic$ref$130aurmcwdfdf1,\n};\n//endregion\n\n"}}]);