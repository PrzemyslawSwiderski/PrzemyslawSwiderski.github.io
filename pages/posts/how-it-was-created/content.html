<ul><li><a href="/posts/how-it-was-created#introduction"> Introduction</a></li><li><a href="/posts/how-it-was-created#building-with-gradle"> Building with Gradle</a></li><li><a href="/posts/how-it-was-created#backend-and-mdhtml-conversion"> Backend and MDðŸ‘‰HTML conversion</a></li><li><a href="/posts/how-it-was-created#frontend"> Frontend</a><ul><li><a href="/posts/how-it-was-created#kotlinjs"> Kotlin/JS</a></li><li><a href="/posts/how-it-was-created#bootstrap"> Bootstrap</a></li><li><a href="/posts/how-it-was-created#github-pages-spa-support"> GitHub Pages SPA support</a></li></ul></li><li><a href="/posts/how-it-was-created#common"> Common</a></li><li><a href="/posts/how-it-was-created#development"> Development</a></li><li><a href="/posts/how-it-was-created#cicd"> CI/CD</a></li><li><a href="/posts/how-it-was-created#conclusions"> Conclusions</a></li></ul><h1>Introduction <a id="introduction" href="/posts/how-it-was-created#introduction" class="anchor-link">ðŸ”—</a></h1><p>Initially my personal blog page was using the <a href="https://jekyllrb.com/">Jekyll</a> static site generator.
It was very well-supported by GitHub at that time (Jan 28, 2016).</p><p>Recently I wanted to refresh it. Unfortunately, some time ago I reinstalled my local system,
so I do not have Jekyll Gem package installed anymore. Because of my laziness, I decided to create a whole new site
generation engine in Kotlin ðŸ˜….
Other reason was that I am more familiar with Kotlin than Ruby and wanted to try something new, especially
since there was the new <a href="https://kotlinlang.org/docs/whatsnew20.html">2.0 Kotlin</a> version released lately ðŸ˜‰.</p><p>To keep it simple, I wanted the new generation engine to work in a similar way as Jekyll.
It is processing the Markdown files and generates HTML code based on those.</p><p>In this post I would like to show some technical details of how it was done.</p><p>The whole project and repository can be found
<strong><a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/">HERE</a></strong>.</p><h1>Building with Gradle <a id="building-with-gradle" href="/posts/how-it-was-created#building-with-gradle" class="anchor-link">ðŸ”—</a></h1><p><a href="https://gradle.org/">Gradle</a> is the build system <a href="https://www.jetbrains.com/lp/devecosystem-2023/java/">widely used</a> in
many JVM projects.
Since it is supporting writing build scripts with the Kotlin DSL and has got out off the box Kotlin plugins
it was pretty clear to use it for the Kotlin project.</p><p>What I like the most is that only the Java RE is required to run the build.
It can be invoked by simply calling:</p><ul><li><p><code>./gradlew build</code> on Unix systems</p></li><li><p>or <code>gradlew.bat build</code> on Windows</p></li></ul><p>in the project directory.</p><p>All Java dependencies, Node.js, and NPM packages will be installed in the background.</p><h1>Backend and MDðŸ‘‰HTML conversion <a id="backend-and-mdhtml-conversion" href="/posts/how-it-was-created#backend-and-mdhtml-conversion" class="anchor-link">ðŸ”—</a></h1><p>In order to convert Markdown to HTML files, Kotlin JVM script
<a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/blob/master/src/jvmMain/kotlin/app/MdToHtmlConverter.kt">
<code>MdToHtmlConverter.kt</code></a>
was added. It processes the input catalog and produces the output to the specified directory.
Apart from converting the <code>.md</code> files to HTML ones, it copies other files like images and
produces <code>markdown-metadata.yaml</code> which is later used for the post's entries generation and routes mapping.</p><p>To run the script the <code>generateHtmlFiles</code> task was added. It can be executed solely in a standard way by running:</p><pre><code class="language-sh">./gradlew generateHtmlFiles
</code></pre><h1>Frontend <a id="frontend" href="/posts/how-it-was-created#frontend" class="anchor-link">ðŸ”—</a></h1><h3>Kotlin/JS <a id="kotlinjs" href="/posts/how-it-was-created#kotlinjs" class="anchor-link">ðŸ”—</a></h3><p>For the frontend I am using <a href="https://kotlinlang.org/docs/js-overview.html">Kotlin/JS</a>.
I have to admit that initially it was not easy to get familiar with how it is compiled to a JavaScript.
After understanding <code>external</code>, <code>dynamic</code> concepts and how to import regular JS modules, the development process became
more pleasant.</p><p>Since I am familiar with ReactJS and Kotlin/JS has a <a href="https://kotlinlang.org/docs/js-react.html">support</a> for it,
I decided to choose it as the SPA framework.
JetBrains team is releasing some wrappers for the React e.g. <code>org.jetbrains.kotlin-wrappers:kotlin-react</code>.
They have type mappings for the JavaScript and lets the user write type-safe React code in Kotlin like this:</p><pre><code class="language-kotlin">import react.FC
import react.dom.html.ReactHTML.li
import react.dom.html.ReactHTML.nav
import react.dom.html.ReactHTML.ul
import react.router.dom.NavLink

val NavBar = FC {
    nav {
        withClasses(&quot;navbar navbar-expand-sm&quot;)
        ul {
            withClasses(&quot;navbar-nav&quot;)
            li {
                asNavItem()
                NavLink {
                    withClasses(&quot;nav-link&quot;)
                    to = &quot;/&quot;
                    +&quot;About&quot;
                }
            }
            (...)
</code></pre><p>which matches the following Typescript code:</p><pre><code class="language-tsx">import React from &quot;react&quot;;

const NavBar: React.FC = () =&gt; {
return (
&lt;nav class=&quot;navbar navbar-expand-sm&quot;&gt;
    &lt;ul class=&quot;navbar-nav&quot;&gt;
        &lt;li class=&quot;nav-item&quot;&gt;
            &lt;NavLink class=&quot;nav-link active&quot; to=&quot;/&quot;&gt;About&lt;/NavLink&gt;
        &lt;/li&gt;
&lt;/nav&gt;;
);
};
</code></pre><p>This is pretty good alternative for someone who do not like XML tags (like me ðŸ˜…) and finds it easier to read.
It is also quite powerful with Kotlin extension function like <code>withClasses()</code> and <code>asNavItem()</code> in the example.
AFAIK it is not possible in JS or Typescript to do such things that easily.</p><h3>Bootstrap <a id="bootstrap" href="/posts/how-it-was-created#bootstrap" class="anchor-link">ðŸ”—</a></h3><p>In order to make the application responsive Bootstrap and Sass toolkit was used.
The integration wasn't so smooth and I spent some time on setting up the Webpack config.
Instead of the separate CSS modules I wanted to make a single <code>main.css</code> which I could include in <code>index.html</code>.</p><p>Initially I thought Kotlin Multiplatform plugin would help me with it, unfortunately it is not possible and its
KotlinDSL options does not allow such things. I had to create a custom <code>webpack.config.d/loaders.config.js</code>
and add <code>css</code>, <code>sass</code> etc. dependencies manually.</p><p>After some hard time spent while setting this up, I was able to make <code>src/jsMain/resources/scss</code> to be bundled into
a single CSS file ðŸ¥³.</p><h3>GitHub Pages SPA support <a id="github-pages-spa-support" href="/posts/how-it-was-created#github-pages-spa-support" class="anchor-link">ðŸ”—</a></h3><p>Since GitHub Pages does not support SPA apps out of the box some additional actions were needed.
I used the existing solution found <a href="https://github.com/rafgraph/spa-github-pages">here</a>.
Some additional JS scripts and custom <code>404.html</code> page was needed, but I managed to <code>&lt;BrowserRouter/&gt;</code> React component
work properly.</p><h1>Common <a id="common" href="/posts/how-it-was-created#common" class="anchor-link">ðŸ”—</a></h1><p>Using Kotlin Multiplatform setup can be also useful if we would like to define a common Frontend and Backend components.
In this project I created
<a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/blob/master/src/commonMain/kotlin/app/model/MdMetadata.kt">
<code>MdMetadata.kt</code></a>
file which is the model class for the metadata output from Backend and the same is being used as the input to a
frontend router and HTML imports.</p><p>Serialization/Deserialization was done thanks to Kotlinx serialization dependency compatible for both JVM and JS parts.</p><h1>Development <a id="development" href="/posts/how-it-was-created#development" class="anchor-link">ðŸ”—</a></h1><p>For the local development there is a separate <code>jsRun</code> Gradle task.</p><p>By executing <code>./gradlew jsRun -t</code> Gradle is running the development server locally and rebuilds the application if the
source files changes.</p><p>Changes are visible in few seconds:</p><p><img src="/pages/posts/how-it-was-created/live-changes.gif" alt="Live reload" class="markdown-img" /></p><p>As it can be seen in the <code>jsRun</code> task's logs, changes done in <code>content.md</code> file triggered rebuilding because the
whole <code>pages</code> catalog was specified as the input of <code>generateHtmlFiles</code> task in
<a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/blob/master/build.gradle.kts">build.gradle.kts</a>
file.
Gradle is somehow able to figure out that the build cache is invalid and due to dependency on <code>jsProcessResources</code> task:</p><pre><code class="language-kotlin">named(&quot;jsProcessResources&quot;) {
    dependsOn(generateHtmlFiles)
}
</code></pre><p>it detects changes and rebuilds the app.</p><p>It is pretty impressive that we can execute some Kotlin JVM code with <code>generateHtmlFiles</code> task and see the output on
frontend almost instantly ðŸ˜Ž.</p><h1>CI/CD <a id="cicd" href="/posts/how-it-was-created#cicd" class="anchor-link">ðŸ”—</a></h1><p>On each push to master the GitHub action specified
in <a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/blob/master/.github/workflows/gh-pages.yml">gh-pages.yml</a>
is invoked. It builds project with Gradle and deploys new static resource by simply pushing output files to <code>gh-pages</code>
branch. The push/commit is executed by <a href="https://github.com/peaceiris/actions-gh-pages"><code>peaceiris/actions-gh-pages</code></a>
action.</p><p>Cool thing is that you can edit MD files directly from GitHub site:</p><p><img src="/pages/posts/how-it-was-created/github-edit.png" alt="Edit MD file directly" class="markdown-img" /></p><p>and see the changes in a few minutes after
commiting the changes to master.</p><h1>Conclusions <a id="conclusions" href="/posts/how-it-was-created#conclusions" class="anchor-link">ðŸ”—</a></h1><p>To sum up, because of the Gradle and its Kotlin (both JVM and JS) support I was able to create basic Jekyll like Single
Page Application template which lets the user to easily manage the blog entries and structure.</p><p>To be fair I am not sure yet whether I would use Kotlin/JS in more complex enterprise scenarios, but I definitely see
some potential in terms of making JS frontend apps easier to maintain and less error-prone.</p><p>I also need to admit that both Kotlin and Gradle are becoming better in terms of performance and development experience
with each new version. Intellij IDE support for these tools is also priceless.
I feel like the autocompletion, compilation times and development experience improved a lot comparing to some older
2018 versions. I don't have the exact numbers but with the new Kotlin 2.0
<a href="https://blog.jetbrains.com/kotlin/2024/05/celebrating-kotlin-2-0-fast-smart-and-multiplatform/">improvements</a>
I can confirm that it is noticeably faster.</p><p>Project can be found in the following
<a href="https://github.com/PrzemyslawSwiderski/PrzemyslawSwiderski.github.io/">repo</a>.
Feel free to use it as the template for the personal blog or some more sophisticated case ðŸ˜„.</p>