<ul><li><a href="/posts/git-branch-update#updating-your-git-feature-branch-without-merge-commits-or-rebases"> Updating Your Git Feature Branch Without Merge Commits or Rebases</a><ul><li><a href="/posts/git-branch-update#the-problem"> The Problem</a></li><li><a href="/posts/git-branch-update#the-solution-reset-and-reapply"> The Solution: Reset and Reapply</a><ul><li><a href="/posts/git-branch-update#step-1-create-a-safety-backup"> Step 1: Create a Safety Backup</a></li><li><a href="/posts/git-branch-update#step-2-fetch-the-latest-changes"> Step 2: Fetch the Latest Changes</a></li><li><a href="/posts/git-branch-update#step-3-reset-your-branch"> Step 3: Reset Your Branch</a></li><li><a href="/posts/git-branch-update#step-4-reapply-your-changes"> Step 4: Reapply Your Changes</a></li></ul></li><li><a href="/posts/git-branch-update#even-simpler-the-squash-approach"> Even Simpler: The Squash Approach</a></li><li><a href="/posts/git-branch-update#when-to-use-this-approach"> When to Use This Approach</a></li><li><a href="/posts/git-branch-update#important-notes"> Important Notes</a></li><li><a href="/posts/git-branch-update#cleanup"> Cleanup</a></li></ul></li><li><a href="/posts/git-branch-update#conclusion"> Conclusion</a></li></ul><h2>Updating Your Git Feature Branch Without Merge Commits or Rebases <a id="updating-your-git-feature-branch-without-merge-commits-or-rebases" href="/posts/git-branch-update#updating-your-git-feature-branch-without-merge-commits-or-rebases" class="anchor-link">ðŸ”—</a></h2><p>When working on a feature branch in Git, you often need to incorporate the latest changes from your main branch. While
merge commits and rebases are the standard approaches, sometimes you may want a cleaner alternative ðŸ˜‰.</p><h3>The Problem <a id="the-problem" href="/posts/git-branch-update#the-problem" class="anchor-link">ðŸ”—</a></h3><p>You're working on a feature branch, and your main branch has moved forward with new commits. You need to update your
feature branch, but:</p><ul><li>You don't want merge commits cluttering your history</li><li>You want to avoid the complexity of interactive rebasing</li></ul><h3>The Solution: Reset and Reapply <a id="the-solution-reset-and-reapply" href="/posts/git-branch-update#the-solution-reset-and-reapply" class="anchor-link">ðŸ”—</a></h3><p>The simplest approach is to reset your feature branch to the latest main and reapply your changes. Here's how:</p><h4>Step 1: Create a Safety Backup <a id="step-1-create-a-safety-backup" href="/posts/git-branch-update#step-1-create-a-safety-backup" class="anchor-link">ðŸ”—</a></h4><p>Always create a backup of your current work before doing any destructive operations:</p><pre><code class="language-bash">git checkout feature-branch
git branch feature-branch-backup
</code></pre><h4>Step 2: Fetch the Latest Changes <a id="step-2-fetch-the-latest-changes" href="/posts/git-branch-update#step-2-fetch-the-latest-changes" class="anchor-link">ðŸ”—</a></h4><p>Get the latest commits from the remote repository:</p><pre><code class="language-bash">git fetch origin
</code></pre><h4>Step 3: Reset Your Branch <a id="step-3-reset-your-branch" href="/posts/git-branch-update#step-3-reset-your-branch" class="anchor-link">ðŸ”—</a></h4><p>Reset your feature branch to match the target branch (usually <code>main</code> or <code>develop</code>):</p><pre><code class="language-bash">git reset --hard origin/main
</code></pre><p>This moves your branch pointer to the latest commit on <code>main</code>, effectively &quot;updating&quot; your base.</p><h4>Step 4: Reapply Your Changes <a id="step-4-reapply-your-changes" href="/posts/git-branch-update#step-4-reapply-your-changes" class="anchor-link">ðŸ”—</a></h4><p>Now cherry-pick your original commits back onto the updated branch:</p><pre><code class="language-bash">git cherry-pick commit1 commit2 commit3
</code></pre><p>Or if you know the commit range:</p><pre><code class="language-bash">git cherry-pick base-commit..feature-branch-backup
</code></pre><h3>Even Simpler: The Squash Approach <a id="even-simpler-the-squash-approach" href="/posts/git-branch-update#even-simpler-the-squash-approach" class="anchor-link">ðŸ”—</a></h3><p>If you haven't pushed your feature branch yet and don't mind squashing all your work into a single commit, this is even
easier:</p><pre><code class="language-bash">git fetch origin
git reset --soft origin/main
git commit -m &quot;Add feature: your feature description&quot;
</code></pre><p>This approach:</p><ol><li>Moves your branch pointer to the latest main</li><li>Keeps all your changes staged (thanks to <code>--soft</code>)</li><li>Lets you create one clean commit with all your work</li></ol><h3>When to Use This Approach <a id="when-to-use-this-approach" href="/posts/git-branch-update#when-to-use-this-approach" class="anchor-link">ðŸ”—</a></h3><p>This method works best when:</p><ul><li>You want a linear history without merge commits</li><li>You're comfortable creating new commit SHAs</li><li>You haven't shared your branch with others (or can force-push)</li><li>You want a cleaner alternative to interactive rebase</li></ul><h3>Important Notes <a id="important-notes" href="/posts/git-branch-update#important-notes" class="anchor-link">ðŸ”—</a></h3><ul><li>If you've already pushed your feature branch, you'll need to force-push:
  <code>git push --force-with-lease origin feature-branch</code></li><li>The <code>--force-with-lease</code> flag is safer than <code>--force</code> as it won't overwrite work if someone else has pushed to your
  branch</li><li>Always coordinate with your team before force-pushing to shared branches</li></ul><h3>Cleanup <a id="cleanup" href="/posts/git-branch-update#cleanup" class="anchor-link">ðŸ”—</a></h3><p>Once you've verified everything works, you can delete your backup branch:</p><pre><code class="language-bash">git branch -D feature-branch-backup
</code></pre><hr /><h2>Conclusion <a id="conclusion" href="/posts/git-branch-update#conclusion" class="anchor-link">ðŸ”—</a></h2><p>This approach gives you a clean, linear history without the complexity of rebasing or the clutter of merge commits. It's
particularly useful for personal feature branches where you want to maintain a tidy commit history.</p>